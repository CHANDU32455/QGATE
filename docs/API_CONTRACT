# API Contract — Q-Gate (Post-Quantum Authentication)

This file documents the canonical HTTP endpoints, request/response JSON schemas, Redis key formats and QR payload for the Q-Gate system. All endpoints use JSON and expect/return binary data as base64-encoded strings where necessary (keys/signatures). Use Buffers/Uint8Arrays on the server side to avoid encoding issues.

---

## Conventions
- Content-Type: `application/json`
- Binary fields (public keys / signatures / nonces) are transmitted as **base64** strings over JSON and converted to `Buffer`/`Uint8Array` server-side.
- Opaque tokens: `256-bit` (32 byte) hex strings generated by `crypto.randomBytes(32).toString('hex')`.
- Redis keys/TLLs:
  - `challenge:[sessionId]` -> JSON { nonce: base64, regUserId, status } — TTL: 120s (2m)
  - `session:[token]` -> JSON { userId, status: 'authenticated' } — TTL: configurable (e.g., 1h)

---

## Endpoints

### POST /api/register
- Description: Register a new device/user by sending a PQ public key.
- Request body:
  - `{ "username": "alice", "publicKey": "<base64>" }`
- Response (201 Created):
  - `{ "regUserId": "<uuid-or-hash>", "username": "alice" }`
- Notes: Validate `publicKey` length/format on server (expected Dilithium public key size).

---

### POST /api/initiate
- Description: Initiate a new login challenge for a `regUserId`.
- Request body:
  - `{ "regUserId": "<id>" }`
- Response (200 OK):
  - `{ "sessionId": "<uuid>", "challengeNonce": "<base64>" }`
- Server behavior:
  - Generate a 64-byte nonce (`crypto.randomBytes(64)`), store `challenge:[sessionId]` in Redis with TTL 120s.
  - Return both `sessionId` and `challengeNonce` to the caller for QR rendering.

---

### POST /api/verify
- Description: Submit a signature over the challenge (mobile signs nonce).
- Request body:
  - `{ "sessionId": "<id>", "signature": "<base64>" }`
- Response (200 OK) on success:
  - `{ "status": "ok", "token": "<opaqueToken>" }`
- Server behavior on success:
  - Fetch `challenge:[sessionId]` from Redis, get stored `nonce` and `regUserId`.
  - Retrieve `pq_pub_key` from MongoDB for the `regUserId`.
  - Verify signature using PQ library: `dilithium.verify(signature, nonce, pubKey)`.
  - If valid: generate opaque token, store `session:[token]` in Redis and emit `verified` event to Socket.io room `sessionId`.

---

## QR Payload (what is embedded in the QR shown on Web)
- Suggestion (JSON encoded then base64 in QR):
  - `{ "sessionId": "<id>", "challengeNonce": "<base64>" }`
- Alternative: compact encoded string `sessionId|base64(nonce)` if size is a concern.

---

## Socket.io events
- Client (Web) joins: `socket.emit('join-session', { sessionId })`
- Backend emits on success: `socket.to(sessionId).emit('verified', { token: '<opaqueToken>' })`

---

## Error cases & status codes
- 400 Bad Request: malformed JSON or missing fields.
- 401 Unauthorized: invalid signature or expired challenge.
- 404 Not Found: `regUserId` or `sessionId` not found.
- 500 Server Error: unexpected server failures.

---

## Notes
- Use `POST /api/initiate` rather than `GET` to avoid caching or accidental prefetching by browsers that could leak or reuse nonces. POST is explicit for state-changing challenge generation.
- Preserve binary fidelity: always decode base64 into Buffer and never treat binary as UTF-8 strings.

*End of API Contract.*